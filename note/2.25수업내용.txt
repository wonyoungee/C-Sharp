형상관리 따로 과제 줌.
1,3번만 계획해서 월요일까지 조별 게시판에 올리기.(조장이)

<협업툴>
1. 슬랙
2. 트렐로 의무 + 조별 선택

자기분석 과제 - 3.6까지
----------------------------------------------------------------------------

*라이브러리 : 일부 기능
*프레임워크 : 다 할 수 있음 (놀이공원 같은 것-내가 선택만 하면 원하는 것 탈 수 있음)
*버전 : 새로운 것 나왔다는 걸 기록

*.net core : 크로스. 닷넷 프레임워크 사용 가능. 맥에서도 가능.

1.프레임워크 선택 -> 2. 언어 선택 -> 3. 창 선택 (어플리케이션) -> 4. 브라우저-해석기-실행엔진(브라우저는 아직 html, css, js 만 해석할 수 있는 엔진을 가지고 있음.) -> 5. 백다이얼-서버(c#사용)-db연결-브라우저가 해석할 수 있도록 렌더링-클라이언트가 해석

*브라우저의 한계점 : 해석 가능한 언어가 정해져있음.

*왜 c#을 배워야하는가?
-> 서버에서 동작하는 언어를 배워야 하기 때문. 브라우저가 해석할 수 있는 언어는 한계가 존재.

*c#으로 web개발. 데이터 연동.

*MVC 패턴 : 업무분담을 위한 것. (협업-동시에 나누어서 개발)
*model : dao (데이터 처리), dto (vo=value object(값을 가진 객체)=domain) (data transfer object) (데이터를 저장할 수 있는 공간) > java, c#, service
*view : 화면 > html, css, js
*controller : 상황실(통제) > java(servlet), c#

*mpa : 서버가 모든 걸 처리->네트워크 트래픽 증가
*spa : 컴퍼넌트 처리 (필요한 데이터만 json형태로 받음. 즉, 디자인 필요없이 데이터만 받으면 됨)-> 서버가 처리하는 작업량 감소
* 최근 : 실행주체 : 서버->개인pc(클라이언트)로 넘어가는 추세.

*rest api : 웹서비스. 데이터만 넘겨주는 것. 

*절차적 프로그래밍 vs 객체지향 프로그래밍

*솔루션>프로젝트>소스

*stack : 데이터 쌓이는 공간 (LIFO)

*Emp.cs 컴파일 (Main() 실행함수) >> Emp.exe
*Emp.cs 컴파일 (Main() X) >> Emp.dll (단독으로 실행이 불가능) : lib

*실행> Emp.exe 엔터
*메모리 > OS > 메모리 (.Net이 사용영역 분리) > 4가지로 분리 (code, data, stack, heap)

*코드 정보를 먼저 로드 (버전, 권한, 사용 lib)
*static 보이면 data 영역 메모리에 로드 - 그래서 static 자원은 new 하기 전에 사용 가능
  static void 함수의 이름이 Main이면 -> stack 메모리에 보냄 -> 실행
*heap은 객체가 올라가는 영역

*static 쓰는 것 -> new하지 않아도 되므로 편함.

